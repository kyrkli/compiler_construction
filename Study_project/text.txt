@@ dot ast.gv -Tpng -o ast.png
@ Das sind meine Kommentare
lala
Obana + 123 +++ 12
#
FUNC hailstone real [
]
%
	int->n
	SCANF[int->n]
	int->counter
	PRINT[string->str(Start number is:)end]
	PRINT[int->n]
	PRINT[string->str(Numbers:)end]
	WHILE[int->n ! int->1]
		%
			IF [int->n mod 2 = int->0]
			%
				n = int->n / 2
			$
			ELSE
			%
				n = int->n * 3 + 1
			$
			counter = int->counter + 1
			PRINT[int->n]
		$
	PRINT[string->str()end]
	PRINT[string->str(The last number:)end]
	PRINT[int->n]
	PRINT[string->str(Counter of steps:)end]
	PRINT[int->counter]
$
FUNC permutations int [
intp->arr
int->start
int->end
]
%
	IF [int->start = int->end]
	%
		PRINT[string->str(result:------------------------------------------------)end]
		PRINT[intp->arr]
		PRINT[string->str()end]
	$
	ELSE
	%
		FOR [ int->i
			  =int->start
			  [int->i <= int->end]
			  + -> 1 ]
			  %
			  		@@ swap
			  int->temp
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp
			  CALL permutations [p:intp->arr p:int->start + 1 p:int->end]
			  		@@ backtrack
			  int->temp1
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp1
			  $
	$
$
%
	PRINT[string->str(START OF MAIN)end]
	intp->nums->int->3
	=[el:int->1 el:int->2 el:int->3]
	PRINT[string->str(AFTER ARR DECL AND BEFORE CALL)end]
	CALL permutations [p:intp->nums p:int->0 p:int->2]
	PRINT[string->str(END OF THE PROGRAMM)end]
$
