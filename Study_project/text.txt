@@ dot ast.gv -Tpng -o ast.png
@ Das sind meine Kommentare
lala
Obana + 123 +++ 12
#
FUNC hailstone real [
]
%
	int->n
	PRINT[string->str(Enter start number for hailtone sequence)end]
	SCANF[int->n]
	int->counter
	PRINT[string->str(Start number is:)end]
	PRINT[int->n]
	PRINT[string->str(Numbers:)end]
	WHILE[int->n ! int->1]
		%
			IF [int->n mod 2 = int->0]
			%
				n = int->n / 2
			$
			ELSE
			%
				n = int->n * 3 + 1
			$
			counter = int->counter + 1
			PRINT[int->n]
		$
	PRINT[string->str()end]
	PRINT[string->str(The last number:)end]
	PRINT[int->n]
	PRINT[string->str(Counter of steps:)end]
	PRINT[int->counter]
$
FUNC permutations int [
intp->arr
int->start
int->end
]
%
	IF [int->start = int->end]
	%
		PRINT[string->str(result:------------------------------------------------)end]
		PRINT[intp->arr]
		PRINT[string->str()end]
	$
	ELSE
	%
		FOR [ int->i
			  =int->start
			  [int->i <= int->end]
			  + -> 1 ]
			  %
			  		@@ swap
			  int->temp
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp
			  CALL permutations [p:intp->arr p:int->start + 1 p:int->end]
			  		@@ backtrack
			  int->temp1
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp1
			  $
	$
$
FUNC start_permutations int [
]
%
	int->N
	PRINT[string->str(Enter how many numbers do you want to input)end]
	SCANF[int->N]
	intp->arr->int->N
	FOR [ int->i
		  =int->0
		  [int->i < int->N]
		  + -> 1 ]
		  %
			SCANF[intp->arr[int->i]]
		  $
	CALL permutations [p:intp->arr p:int->0 p:int->N - 1]
$
FUNC calculation_trainer int [
]
%
	PRINT[string->str(Start calc trainer)end, char->nl]
	int->num_of_op
	=int->5
	int->num_of_num
	=int->num_of_op + 1
	intp->nums->int->num_of_num
	@@ set random numbers
	FOR[int->i
		=int->0
		[int->i < int->num_of_num]
		+ -> 1]
		%
			nums[int->i] = int->RANDOM[int->1 int->10]
		$
	string->ops
	@@ set random ops
	FOR[int->i
		=int->0
		[int->i < int->num_of_op]
		+ -> 1]
		%
			int->num_op
			=int->RANDOM[int->1 int->6]
			IF [int->num_op = int-> 1]
			%
				ops[int->i] = char->'-'
			$
			ELSE
			%
				IF [int->num_op = int-> 2]
				%
					ops[int->i] = char->'+'
				$
				ELSE
				%
					IF [int->num_op = int-> 3]
					%
						ops[int->i] = char->'*'
					$
					ELSE
					%
						IF [int->num_op = int-> 4]
						%
							ops[int->i] = char->'/'
						$
						ELSE
						%
							IF [int->num_op = int-> 5]
							%
								ops[int->i] = char->'^'
							$
							ELSE
							%
								ops[int->i] = char->'m'
							$
						$
					$
				$
			$
		$
	@@print the term
	PRINT[int->nums[int->0]]
	FOR[int->i
		=int->0
		[int->i < int->num_of_op]
		+ -> 1]
		%
			PRINT[char->ops[int->i], int->nums[int->i + 1]]
		$
	PRINT[char->nl]
	int->result
	=int-> CALL calc_rec[p:intp->nums p:string->ops]
	PRINT[string->str(Result = )end, int->result, char->nl]
$
FUNC calc_rec int [
intp->nums
string->ops
]
%
	IF [int->ops->SIZE = int->1]
	%
		return = int-> CALL calc_one[p:int->nums[int->0] p:char->ops[int->0] p:int->nums[int->1]]
		PRINT[string->str(Last subterm: )end, int->nums[int->0], char->ops[int->0], int->nums[int->1], char->nl]
		PRINT[string->str(= )end, int->return, char->nl]
	$
	ELSE
	%
		bool->isFound
		=bool->FALSE
		int->index_found
		=int->-1
		string->prior
		=string->str(^m/*+-)end
		FOR[int->j
			=int->0
			[int->j < int->prior->SIZE]
			+ -> 1]
			%
				FOR[int->i
					=int->0
					[int->i < int->ops->SIZE]
					+ -> 1]
					%
						IF [char->ops[int->i] = char->prior[int->j]]
						%
							isFound = bool->TRUE
							index_found = int->i
							i = int->ops->SIZE
						$
					$
				IF isFound
				%
					j = int->prior->SIZE
				$
			$
		@@ the highest priority operation and numbers for it are found
		PRINT[string->str(Subterm: )end, int->nums[int->index_found], char->ops[int->index_found], int->nums[int->index_found + 1], char->nl]
		nums[int->index_found] = int-> CALL calc_one[p:int->nums[int->index_found] p:char->ops[int->index_found] p:int->nums[int->index_found + 1]]
		PRINT[string->str(= )end, int->nums[int->index_found], char->nl]
		@@ prepare newnums array with the calcalated variable
		intp->newnums->int->nums->SIZE - 1
		FOR[int->i
			=int->0
			[int->i <= int->index_found]
			+ -> 1]
		%
			newnums[int->i] = int->nums[int->i]
		$
		FOR[int->i
			=int->index_found + 1
			[int->i < int->newnums->SIZE]
			+ -> 1]
		%
			newnums[int->i] = int->nums[int->i + 1]
		$
		@@ prepare newops array without used operation
		string->newops
		FOR[int->i
			=int->0
			[int->i < int->index_found]
			+ -> 1]
		%
			newops[int->i] = char->ops[int->i]
		$
		FOR[int->i
			=int->index_found
			[int->i < int->ops->SIZE - 1]
			+ -> 1]
		%
			newops[int->i] = char->ops[int->i + 1]
		$
		return = int-> CALL calc_rec[p:intp->newnums p:string->newops]	
	$
$
FUNC calc_one int [
int->num1
char->op
int->num2
]
%
	IF [char->op = char->'-']
	%
		return = int->num1 - num2	
	$
	ELSE
	%
		IF [char->op = char->'+']
		%
			return = int->num1 + num2	
		$
		ELSE
		%
			IF [char->op = char->'*']
			%
				return = int->num1 * num2	
			$
			ELSE
			%
				IF [char->op = char->'/']
				%
					IF [int->num2 = int->0]
					%
						PRINT[string->str(WARNING! Division by 0, the subresult = 0)end, char->nl]
						return = int->0
					$
					ELSE
					%
						return = int->num1 / num2	
					$
				$
				ELSE
				%
					IF [char->op = char->'m']
					%
						return = int->num1 mod num2	
					$
					ELSE
					%
						return = int->num1 ^ num2	
					$
				$
			$
		$
	$
$
%
	PRINT[string->str(START OF MAIN)end, char->nl]
	int->abc
	=int->999
	CALL calculation_trainer []
	PRINT[string->str(END OF THE PROGRAMM)end, char->nl]
$
