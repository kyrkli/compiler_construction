@@ dot ast.gv -Tpng -o ast.png
@ Das sind meine Kommentare
lala
Obana + 123 +++ 12
#
FUNC hailstone real [
]
%
	int->n
	SCANF[int->n]
	int->counter
	PRINT[string->str(Start number is:)end]
	PRINT[int->n]
	PRINT[string->str(Numbers:)end]
	WHILE[int->n ! int->1]
		%
			IF [int->n mod 2 = int->0]
			%
				n = int->n / 2
			$
			ELSE
			%
				n = int->n * 3 + 1
			$
			counter = int->counter + 1
			PRINT[int->n]
		$
	PRINT[string->str()end]
	PRINT[string->str(The last number:)end]
	PRINT[int->n]
	PRINT[string->str(Counter of steps:)end]
	PRINT[int->counter]
$
FUNC permutations int [
intp->arr
int->start
int->end
]
%
	IF [int->start = int->end]
	%
		PRINT[intp->arr]
	$
	ELSE
	%
		FOR [ int->i
			  =int->start
			  [int->i <= int->end]
			  + -> 1 ]
			  %
			  PRINT[string->str(START OF BLOCK-------------------------------------------------)end]
			  PRINT[int->start]
			  		@@ swap
			  int->temp
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp
			  PRINT[string->str(BEFORE RECURSIV CALL -----------------------------------------)end]
			  CALL permutations [p:intp->arr p:int->start + 1 p:int->end]
			  		@@ backtrack
			  int->temp1
			  =int->arr[int->start]
			  arr[int->start] = int->arr[int->i]
			  arr[int->i] = int->temp1
			  $
	$
$
%
	intp->nums->int->6
	=[el:int->1 el:int->2 el:int->3 el:int->4 el:int->5 el:int->6]
	CALL permutations [p:intp->nums p:int->0 p:int->6 - 1]
$
